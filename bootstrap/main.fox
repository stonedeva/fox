import "std.fox"

const OP_PUSH 0 end
const OP_PLUS 1 end
const OP_MINUS 2 end
const OP_MULT 3 end
const OP_DIVI 4 end
const OP_PRINT 5 end
const OP_DUP 6 end
const OP_OVER 7 end
const OP_SWAP 8 end
const OP_DROP 9 end
const OP_ROT 10 end
const OP_NIP 11 end

// struct Ops {
//   type: u64,
//   operand: u64
// }
const MAX_OPS 500 end
const Op.type 0 end
const Op.operand 8 end
const sizeof(Op) 16 end

memory ops sizeof(Op) MAX_OPS * end 
var ops_count 0 end

func usage in
    "Options:\n" @puts
    "	-v	Show current version\n" @puts
    "	-o	Set output path\n" @puts
    "	-l	Dump lexical analysis\n" @puts
    "	-t	Dump type stack\n" @puts
    "	-h	Show help map\n" @puts 
end

func push_op int int in
    if MAX_OPS ops_count == do
	"ERROR: Operation limit has been reached!\n" @eputs
	1 @exit
    end
    take type operand in
	ops ops_count sizeof(Op) * + type set64
	ops ops_count sizeof(Op) * + Op.operand + operand set64
    end
    ops_count 1 + #ops_count
end

func dump_ops in
    // TODO: dump_ops() segfaults after printing all the ops
    // only happens when printing strings
    0 while dup ops_count > do
	"============\n" @puts
	"Type: " @puts
	ops over sizeof(Op) * + get64 print
	"Operand: " @puts
	ops over sizeof(Op) * + Op.operand + get64 print
	1 +
    end
    drop
end

func main in
    OP_PUSH 95 @push_op
    OP_PUSH 10 @push_op
    OP_DUP 0 @push_op
    OP_PLUS 0 @push_op
    OP_PLUS 0 @push_op

    "format ELF64 executable 0\n" @puts
    "entry _start\n" @puts
    "segment readable executable\n" @puts
    "print:\n" @puts
    "    mov r8, -3689348814741910323\n" @puts
    "    sub rsp, 40\n" @puts
    "    mov BYTE [rsp+31], 10\n" @puts
    "    lea rcx, [rsp+30]\n" @puts
    ".L2:\n" @puts
    "    mov rax, rdi\n" @puts
    "    mul r8\n" @puts
    "    mov rax, rdi\n" @puts
    "    shr rdx, 3\n" @puts
    "    lea rsi, [rdx+rdx*4]\n" @puts
    "    add rsi, rsi\n" @puts
    "    sub rax, rsi\n" @puts
    "    mov rsi, rcx\n" @puts
    "    sub rcx, 1\n" @puts
    "    add eax, 48\n" @puts
    "    mov BYTE [rcx+1], al\n" @puts
    "    mov rax, rdi\n" @puts
    "    mov rdi, rdx\n" @puts
    "    cmp rax, 9\n" @puts
    "    ja .L2\n" @puts
    "    lea rdx, [rsp+32]\n" @puts
    "    mov edi, 1\n" @puts
    "    sub rdx, rsi\n" @puts
    "    mov rax, 1\n" @puts
    "    syscall\n" @puts
    "    add rsp, 40\n" @puts
    "    ret\n" @puts
    "_start:\n" @puts

    0 while dup ops_count > do
    	if ops over sizeof(Op) * + get64 OP_PUSH == do
    	    "    ;; --- push int ---\n" @puts
    	    "    mov rax, %d\n" @puts
    	    "    push rax\n" @puts
    	    1 +
    	    continue
    	end
    	if ops over sizeof(Op) * + get64 OP_PLUS == do
    	    "    ;; --- plus ---\n" @puts
    	    "    pop rax\n" @puts
    	    "    pop rbx\n" @puts
    	    "    add rax, rbx\n" @puts
    	    "    push rax\n" @puts
    	    1 +
    	    continue
    	end 
    	if ops over sizeof(Op) * + get64 OP_MINUS == do
    	    "    ;; --- minus ---\n" @puts
    	    "    pop rax\n" @puts
    	    "    pop rbx\n" @puts
    	    "    sub rbx, rax\n" @puts
    	    "    push rbx\n" @puts
    	    1 +
    	    continue
    	end 
    	if ops over sizeof(Op) * + get64 OP_MULT == do
    	    "    ;; --- multiply ---\n" @puts
    	    "    pop rax\n" @puts
    	    "    pop rbx\n" @puts
    	    "    mul rbx\n" @puts
    	    "    push rax\n" @puts
    	    1 +
    	    continue
    	end
    	if ops over sizeof(Op) * + get64 OP_DIVI == do
    	    "    ;; --- divide ---\n" @puts
    	    "    pop rbx\n" @puts
    	    "    pop rax\n" @puts
    	    "	 xor rdx, rdx\n" @puts
    	    "    div rbx\n" @puts
    	    "    push rax\n" @puts
    	    1 +
    	    continue
    	end
    	if ops over sizeof(Op) * + get64 OP_PRINT == do
    	    "    ;; --- print ---\n" @puts
    	    "    pop rdi\n" @puts
    	    "    call print\n" @puts
    	    1 +
    	    continue
    	end
	if ops over sizeof(Op) * + get64 OP_DUP == do
	    "    ;; --- dup ---\n" @puts
	    "    push [rsp]\n" @puts
	    1 +
	    continue
	end
	if ops over sizeof(Op) * + get64 OP_OVER == do
	    "    ;; --- over ---\n" @puts
	    "    push [rsp+8]\n" @puts
	    1 +
	    continue
	end
	if ops over sizeof(Op) * + get64 OP_SWAP == do
	    "    ;; --- swap ---\n" @puts
	    "    pop rax\n" @puts
	    "    pop rbx\n" @puts
	    "    push rbx\n" @puts
	    "    push rax\n" @puts
	    1 +
	    continue
	end
	if ops over sizeof(Op) * + get64 OP_DROP == do
	    "    ;; --- drop ---\n" @puts
	    "    add rsp, 8\n" @puts
	    1 +
	    continue
	end
	if ops over sizeof(Op) * + get64 OP_ROT == do
	    "    ;; --- rot ---\n" @puts
	    "    add rsp, 8\n" @puts
	    "	 mov rax, [rsp + 16]\n" @puts
	    "	 mov rbx, [rsp + 8]\n" @puts
	    "	 mov rcx, [rsp]\n" @puts
	    "	 mov [rsp + 16], rbx\n" @puts
	    "	 mov [rsp + 8], rcx\n" @puts
	    "	 mov [rsp], rax\n" @puts
	    1 +
	    continue
	end
	if ops over sizeof(Op) * + get64 OP_NIP == do
	    "    ;; --- nip ---\n" @puts
	    "    mov rax, [rsp]\n" @puts
	    "    add rsp, 16\n" @puts
	    "    push rax\n" @puts
	    1 +
	    continue
	end
	1 +
    end
    drop

    "    ;; --- exit ---\n" @puts
    "    mov rax, 60\n" @puts
    "    mov rdi, 0\n" @puts
    "    syscall\n" @puts
end
